

# This file was *autogenerated* from the file divide_conquer.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2)
import random
import networkx as nx
from sage.combinat.root_system.coxeter_matrix import CoxeterMatrix

# Supprime si non nécessaire
# load("test_case.sage")

def is_level_0(CM):
    """
    Retourne True si la CoxeterMatrix est de niveau 0 (finie ou affine).
    """
    return CM.is_finite() or CM.is_affine()

def articulation_points(CM):
    """
    Retourne la liste des points d'articulation du graphe associé à CM.
    """
    CG = CM.coxeter_graph()
    nxG = CG.networkx_graph()
    return list(nx.articulation_points(nxG))

def delete_node(CM, articulation_pts):
    """
    Supprime un point d'articulation aléatoire de CM, retourne une liste de sous-CoxeterMatrix.
    """
    if not articulation_pts:
        print("No articulation points found.")
        return [CM]

    node = random.choice(articulation_pts)
    M = CM._matrix # Extraire la vraie matrice
    indices = [i for i in range(M.nrows()) if i != node]
    reduced_matrix = M.submatrix(indices, indices)
    G = Graph()

    # Reconstruire graphe à partir de la sous-matrice
    for i in range(reduced_matrix.nrows()):
        for j in range(i+_sage_const_1 , reduced_matrix.ncols()):
            if reduced_matrix[i, j] != _sage_const_1 :
                G.add_edge(i, j)

    result = []
    for component in G.connected_components():
        component = sorted(component)
        submat = reduced_matrix.submatrix(component, component)
        result.append(CoxeterMatrix(submat))

    return result

def divide(CM):
    """
    Divise la CoxeterMatrix en supprimant un point d'articulation aléatoire.
    """
    return delete_node(CM, articulation_points(CM))

def get_level(CM):
    """
    Calcule récursivement le niveau d'une CoxeterMatrix.
    """
    if is_level_0(CM):
        return _sage_const_0 

    subgraphs = divide(CM)
    levels = [get_level(subgraph) for subgraph in subgraphs]
    return _sage_const_1  + max(levels)

def main():
    CM = CoxeterMatrix([
        [_sage_const_1 , _sage_const_3 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_2 , _sage_const_2 , _sage_const_2 ],
        [_sage_const_3 , _sage_const_1 , _sage_const_2 , _sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_2 , _sage_const_3 ],
        [_sage_const_3 , _sage_const_2 , _sage_const_1 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_3 ],
        [_sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_1 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_2 ],
        [_sage_const_2 , _sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_1 , _sage_const_2 , _sage_const_2 , _sage_const_2 ],
        [_sage_const_2 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_2 , _sage_const_1 , _sage_const_3 , _sage_const_3 ],
        [_sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_1 , _sage_const_3 ],
        [_sage_const_2 , _sage_const_3 , _sage_const_3 , _sage_const_2 , _sage_const_2 , _sage_const_3 , _sage_const_3 , _sage_const_1 ]
    ])

    print("Niveau de la matrice :", get_level(CM))

main()

